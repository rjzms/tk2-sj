[
  {"id":1, "type":"填空题", "q":"Vue是一套用于构建 ____ 的渐进式框架。", "a":"用户界面", "desc":"Vue是一套用于构建用户界面的渐进式框架。"},
  {"id":2, "type":"填空题", "q":"Vue中的指令以 ____ 开头。", "a":"v-", "desc":"Vue中的指令以 v- 开头。"},
  {"id":3, "type":"填空题", "q":"Node.js是一个基于 ____ 引擎的JavaScript运行环境。", "a":"V8", "desc":"Node.js是一个基于 V8 引擎的JavaScript运行环境。"},
  {"id":4, "type":"填空题", "q":"在yarn中，____ 命令用于添加指定名称的包。", "a":"yarn add", "desc":"在yarn中，yarn add 命令用于添加指定名称的包。"},
  {"id":5, "type":"填空题", "q":"在npm中，____ 命令用于卸载指定名称的包。", "a":"npm uninstall", "desc":"在npm中，npm uninstall 命令用于卸载指定名称的包。"},
  {"id":6, "type":"判断题", "q":"在Vue项目中，执行yarn dev命令可以完成项目构建。", "a":"错", "desc":"**解析：** `yarn dev` 通常用于启动本地开发服务器（热更新）。构建生产环境代码通常使用 `yarn build` 命令。"},
  {"id":7, "type":"判断题", "q":"在Vue项目中，执行npm update命令可以更新指定名称的包。", "a":"对", "desc":"**解析：** `npm update <package_name>` 用于更新指定的包到符合语义化版本规则的最新版本。"},
  {"id":8, "type":"判断题", "q":"npm是一个包管理工具，用来解决Node.js的部署问题。", "a":"错", "desc":"**解析：** npm (Node Package Manager) 主要用于管理项目的**依赖包**（安装、卸载、更新），而非专门用于解决“部署”问题（部署通常涉及CI/CD、服务器配置等）。"},
  {"id":9, "type":"判断题", "q":"在使用yarn之前，需要先确保计算机中已经安装了Node.js。", "a":"对", "desc":"**解析：** Yarn 是一个基于 Node.js 开发的包管理工具，因此必须依赖 Node.js 运行环境。"},
  {"id":10, "type":"判断题", "q":"Vue可以在Node.js环境下进行开发，并借助npm工具安装依赖。", "a":"对", "desc":"**解析：** 现代 Vue 开发通常基于 Node.js 工具链（如 Vite/Webpack），并使用 npm/yarn 管理项目依赖。"},
  {"id":11, "type":"单选题", "q":"下列选项中，关于Vue说法错误的是（）。", "opts":{"A":"Vue比Angular和React而言，是一个轻量级的前端库","B":"Vue支持Pinia插件","C":"Vue支持双向数据绑定","D":"Vue中自定义指令以“on-”开头"}, "a":"D", "desc":"**解析：** Vue的指令（包括内置和自定义）均以 v- 开头（例如 v-model, v-focus）。on- 通常是原生HTML事件绑定的前缀，在Vue中绑定事件使用 v-on: 或简写 @。"},
  {"id":12, "type":"单选题", "q":"下列选项中，关于npm工具说法正确的是（）。", "opts":{"A":"使用npm安装同一个包时，会对包进行缓存，再次安装时无须重复下载","B":"npm安装包时，必须等到当前包安装完成后才会继续后面的安装","C":"使用“npm install -g”命令将包安装到当前项目中","D":"使用npm命令时，不需要安装Node.js"}, "a":"B", "desc":"**解析：** A虽然npm有缓存机制，但“无须重复下载”表述不绝对，需校验版本；B正确描述了npm安装过程的同步阻塞特性（按顺序执行）；C选项 -g 是全局安装，不安装在当前项目；D选项npm必须依赖Node.js环境。"},
  {"id":13, "type":"单选题", "q":"下列选项中，关于MVVM的说法错误的是（）。", "opts":{"A":"Model主要负责业务数据的处理","B":"View负责视图的处理","C":"ViewModel负责监听Model或者View的改变","D":"Model和View可以直接通信，互相监控双方的动作，并及时进行相应操作"}, "a":"D", "desc":"**解析：** 在MVVM模式中，Model（数据层）和 View（视图层）**永远不能**直接通信，必须通过 ViewModel 进行中转和双向绑定。"},
  {"id":14, "type":"单选题", "q":"npm包管理工具基于的运行环境是（）。", "opts":{"A":"Node.js","B":"Vue","C":"Babel","D":"Angular"}, "a":"A", "desc":"**解析：** npm (Node Package Manager) 是随 Node.js 一起安装的包管理工具，运行在 Node.js 环境中。"},
  {"id":15, "type":"多选题", "q":"下列选项中，属于Vue特性的是（）（多选）", "opts":{"A":"轻量级","B":"数据驱动视图","C":"双向数据绑定","D":"插件化开发"}, "a":"B、C、D", "desc":"**解析：** 虽然Vue相对轻量，但B、C、D是Vue作为框架的核心技术特性。数据驱动、双向绑定（v-model）、插件机制是其架构基础。"},
  {"id":16, "type":"简答题", "q":"请简述 Vue 的特性", "a":"Vue 的特性如下：\n①数据驱动视图：在使用 Vue 的页面中，Vue 会监听数据变化，当页面数据发生变化时，Vue 会自动重新渲染页面结构。\n②双向数据绑定：Vue 实现了双向数据绑定，即当数据发生变化时，视图也会发生变化；当视图发生变化时，数据也会跟着同步变化。\n③指令：指令主要包括内置指令和自定义指令，内置指令是 Vue 本身自带的指令，而自定义指令是由用户自己定义的指令。指令的名称以 “v-” 开头，作用于 HTML 中的元素。将指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为。\n④插件：Vue 支持插件，通过加载插件可以实现更多的功能。", "desc":"Vue 的特性如下：\n①数据驱动视图：在使用 Vue 的页面中，Vue 会监听数据变化，当页面数据发生变化时，Vue 会自动重新渲染页面结构。\n②双向数据绑定：Vue 实现了双向数据绑定，即当数据发生变化时，视图也会发生变化；当视图发生变化时，数据也会跟着同步变化。\n③指令：指令主要包括内置指令和自定义指令，内置指令是 Vue 本身自带的指令，而自定义指令是由用户自己定义的指令。指令的名称以 “v-” 开头，作用于 HTML 中的元素。将指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为。\n④插件：Vue 支持插件，通过加载插件可以实现更多的功能。"},
  {"id":17, "type":"简答题", "q":"请简述 MVVM 的组成部分及基本工作原理", "a":"MVVM 主要包含 Model（数据模型）、View（视图）和 ViewModel（视图模型）。其中，Model 是指数据部分，负责业务数据的处理；View 是指视图部分，即用户界面，负责视图处理；ViewModel 用于连接视图与数据模型，负责监听 Model 或者 View 的改变。", "desc":"MVVM 主要包含 Model（数据模型）、View（视图）和 ViewModel（视图模型）。其中，Model 是指数据部分，负责业务数据的处理；View 是指视图部分，即用户界面，负责视图处理；ViewModel 用于连接视图与数据模型，负责监听 Model 或者 View 的改变。"},
  {"id":18, "type":"填空题", "q":"在Vue中，每个单文件组件由 ____、样式与逻辑三部分构成。", "a":"模板", "desc":"在Vue中，每个单文件组件由 模板、样式 与逻辑三部分构成。"},
  {"id":19, "type":"填空题", "q":"Vue中实现数据双向绑定的指令是 ____。", "a":"v-model", "desc":"Vue中实现数据双向绑定的指令是 v-model。"},
  {"id":20, "type":"填空题", "q":"在Vue中，可以通过 ____ 语法将数据输出到页面中。", "a":"Mustache", "desc":"在Vue中，可以通过 Mustache (或 {{ }}) 语法将数据输出到页面中。"},
  {"id":21, "type":"填空题", "q":"reactive()函数通常用来定义 ____ 数据。", "a":"响应式", "desc":"reactive()函数通常用来定义 响应式 数据。"},
  {"id":22, "type":"填空题", "q":"Vue中属性绑定的指令是 ____。", "a":"v-bind", "desc":"Vue中属性绑定的指令是 v-bind。"},
  {"id":23, "type":"判断题", "q":"v-model的trim修饰符可以自动过滤用户输入的首尾空白字符。", "a":"对", "desc":"**解析：** `.trim` 修饰符会自动移除输入内容首尾的空格，常用于表单输入。"},
  {"id":24, "type":"判断题", "q":"ref()函数用于将响应式对象中的单个属性转换为响应式数据。", "a":"错", "desc":"**解析：** 这是 `toRef()` 的功能。`ref()` 通常用于定义基本类型的响应式数据，或将普通对象变为响应式引用。"},
  {"id":25, "type":"判断题", "q":"Vue中绑定样式可以通过v-bind指令操作style属性来实现。", "a":"对", "desc":"**解析：** 可以使用 `:style=\"{ color: 'red' }\"` 的对象语法或数组语法来动态绑定样式。"},
  {"id":26, "type":"判断题", "q":"ref()函数用于将普通数据转换为响应式数据。", "a":"错", "desc":"**解析：** 虽然结果是响应式的，但严格来说 `ref` 创建的是一个**RefImpl 引用对象**（需要通过 `.value` 访问），而 `reactive` 才是将普通对象转换为深层响应式代理的标准方法。此处考察的是两者定义的区别。"},
  {"id":27, "type":"单选题", "q":"下列关于单文件组件的说法中，错误的是（）。", "opts":{"A":"模板用于搭建当前组件的DOM结构","B":"在Vue中，&lt;template&gt;标签中的DOM结构只能有一个根节点","C":"样式用于通过CSS代码为当前组件设置样式","D":"逻辑用于通过JavaScript代码处理组件的数据与业务"}, "a":"B", "desc":"**解析：** 在Vue 2中确实只能有一个根节点，但在Vue 3中，&lt;template&gt; 支持Fragments（多个根节点）。"},
  {"id":28, "type":"单选题", "q":"下列选项中，用于渲染DOM元素的文本内容的指令是（）。", "opts":{"A":"v-bind","B":"v-text","C":"v-on","D":"v-for"}, "a":"B", "desc":"**解析：** v-text 用于更新元素的 textContent。v-bind 绑定属性，v-on 绑定事件，v-for 循环。"},
  {"id":29, "type":"单选题", "q":"下列选项中，用于将响应式对象中的所有属性转换为响应式数据的函数是（）。", "opts":{"A":"ref()","B":"reactive()","C":"toRef()","D":"toRefs()"}, "a":"D", "desc":"**解析：** toRefs() 可以将一个响应式对象（reactive）的所有属性转换为单独的 ref 对象，解构时保持响应性。"},
  {"id":30, "type":"单选题", "q":"下列关于事件修饰符的说法中，错误的是（）。", "opts":{"A":"使用prevent修饰符可以阻止&lt;a&gt;标签的默认跳转行为","B":"使用stop修饰符可阻止默认事件行为","C":"使用capture修饰符可以改变事件的默认执行顺序，从冒泡方式更改为捕获方式","D":"使用self修饰符可以实现只有DOM元素本身才会触发事件"}, "a":"B", "desc":"**解析：** .stop 是阻止**事件冒泡**。阻止默认行为（如表单提交、链接跳转）的是 .prevent。"},
  {"id":31, "type":"单选题", "q":"下列关于v-for的说法中，错误的是（）。", "opts":{"A":"使用v-for时，要指定key的值，key的值不具有唯一性","B":"v-for可以辅助开发者基于一个数组、对象、数字或字符串循环渲染一个列表","C":"v-for会根据数组中元素的个数来决定循环次数","D":"v-for会根据对象中属性的个数来决定循环次数"}, "a":"A", "desc":"**解析：** Vue中 v-for 的 key 值必须具有**唯一性**（如ID），否则虚拟DOM在Diff算法对比时会出现错误，导致渲染异常。"},
  {"id":32, "type":"简答题", "q":"单文件组件由哪几部分组成，其各自的作用是什么？", "a":"Vue 单文件组件由三部分构成：\n<template> 结构：定义组件的 HTML 结构和布局。\n<script> 逻辑：处理组件逻辑，管理数据和方法。\n<style> 样式：设置组件样式，可使用 scoped 属性确保样式只在本组件生效。", "desc":"Vue 单文件组件由三部分构成：\n<template> 结构：定义组件的 HTML 结构和布局。\n<script> 逻辑：处理组件逻辑，管理数据和方法。\n<style> 样式：设置组件样式，可使用 scoped 属性确保样式只在本组件生效。"},
  {"id":33, "type":"简答题", "q":"Vue3 中定义响应式数据的常用函数有几种，分别是什么？", "a":"在 Vue 3 中，定义和处理响应式数据的常用函数有以下四种：\nref () 函数：用于将数据转换成响应式数据，其参数为数据。返回值为转换后的响应式数据。通过.value 访问和修改值。\nreactive () 函数：用于创建一个响应式对象或数组，将普通的对象或数组作为参数传递给该函数。可以直接访问属性。\ntoRef () 函数：用于将响应式对象中的单个属性转换为响应式数据，该数据保持与源属性的响应式连接。\ntoRefs () 函数：用于将响应式对象中的所有属性转换为响应式数据。", "desc":"在 Vue 3 中，定义和处理响应式数据的常用函数有以下四种：\nref () 函数：用于将数据转换成响应式数据，其参数为数据。返回值为转换后的响应式数据。通过.value 访问和修改值。\nreactive () 函数：用于创建一个响应式对象或数组，将普通的对象或数组作为参数传递给该函数。可以直接访问属性。\ntoRef () 函数：用于将响应式对象中的单个属性转换为响应式数据，该数据保持与源属性的响应式连接。\ntoRefs () 函数：用于将响应式对象中的所有属性转换为响应式数据。"},
  {"id":34, "type":"操作题", "q":"请实现比较2个数字大小的页面。", "a":"<template>\n  <div>\n    <div>\n      <text>请输入第1个数字:</text>\n      <input type=\"number\" @input=\"num1Input\" />\n    </div>\n    <div>\n      <text>请输入第2个数字:</text>\n      <input type=\"number\" @input=\"num2Input\" />\n    </div>\n    <button @click=\"compare\">比较</button>\n    <div>\n      <text v-if=\"result\">比较结果:{{ result }}</text>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\n// 响应式数据定义\nlet result = ref(\"\")\nlet num1 = ref(0)\nlet num2 = ref(0)\n\n// 第一个数字输入事件处理\nconst num1Input = (event) => {\n  num1.value = Number(event.target.value) // 修正: ref数据需要通过.value修改\n  console.log(num1.value)\n}\n\n// 第二个数字输入事件处理 (修正原代码的赋值运算符错误)\nconst num2Input = (event) => {\n  num2.value = Number(event.target.value) // 修正: ref数据需要通过.value修改\n  console.log(num2.value)\n}\n\n// 比较逻辑处理\nconst compare = () => {\n  if (num1.value > num2.value) { // 修正: ref数据需要通过.value访问\n    result.value = '第1个数大'\n  } else if (num1.value < num2.value) { // 修正: ref数据需要通过.value访问\n    result.value = '第2个数大'\n  } else {\n    result.value = '两数相等'\n  }\n}\n</script>\n\n<style>\n/* 可在此添加样式 */\n</style>", "desc":"操作题：比较2个数字大小（修正版）。"},
  {"id":35, "type":"填空题", "q":"在使用选项式API时，可以通过 ____ 选项来定义方法。", "a":"methods", "desc":"在使用选项式API时，可以通过 methods 选项来定义方法。"},
  {"id":36, "type":"填空题", "q":"组合式API下的 ____ 函数在组件实例被销毁时执行。", "a":"onBeforeUnmount()", "desc":"组合式API下的 onBeforeUnmount() 函数在组件实例被销毁时执行。"},
  {"id":37, "type":"填空题", "q":"在Vue中，可以通过Vue应用实例的 ____ 方法实现全局组件的注册。", "a":"component()", "desc":"在Vue中，可以通过Vue应用实例的 component() 方法实现全局组件的注册。"},
  {"id":38, "type":"填空题", "q":"在组件的&lt;template&gt;标签中可以引用其他组件，被引用的组件需要写成 ____ 的形式。", "a":"标签", "desc":"在组件的&lt;template&gt;标签中可以引用其他组件，被引用的组件需要写成 标签 的形式。"},
  {"id":39, "type":"填空题", "q":"在Vue中，可以通过 ____ 实现子组件向父组件传递数据。", "a":"自定义事件", "desc":"在Vue中，可以通过 自定义事件 实现子组件向父组件传递数据。"},
  {"id":40, "type":"判断题", "q":"当使用组合式API时，数据和方法可以直接在setup()函数中定义。", "a":"对", "desc":"**解析：** `setup()` 是组合式 API 的入口，数据和方法在其中定义并通过 `return` 暴露给模板（或使用 `<script setup>` 自动暴露）。"},
  {"id":41, "type":"判断题", "q":"在Vue中，可以通过type属性对父组件中传递过来的props数据进行基础类型检查。", "a":"对", "desc":"**解析：** 在 props 定义中，可以使用 `type: String`、`type: Number` 等方式进行运行时类型验证。"},
  {"id":42, "type":"判断题", "q":"在Vue中，可以调用defineProps()函数声明props。", "a":"对", "desc":"**解析：** `defineProps` 是 `<script setup>` 语法糖中用于声明 props 的编译器宏。"},
  {"id":43, "type":"判断题", "q":"在父组件中使用v-bind可以为子组件传递绑定props。", "a":"错", "desc":"**解析：** 这是一个咬文嚼字的题。父组件使用 `v-bind` (或 `:`) 绑定的是 **HTML 属性 (Attribute)**，子组件通过 **props 选项接收** 数据。虽然行为上是传值，但术语上“绑定props”这种说法不严谨，应该是“传递数据给props接收”。"},
  {"id":44, "type":"判断题", "q":"在Vue中，跨级组件之间的数据传递可以通过依赖注入来实现。", "a":"对", "desc":"**解析：** 使用 `provide`（提供）和 `inject`（注入）可以实现跨层级组件通信。"},
  {"id":45, "type":"单选题", "q":"下列选项中，关于组合式API下的生命周期函数说法错误的是（）。", "opts":{"A":"onBeforeMount()函数会在组件挂载之前被调用","B":"onMounted()函数会在组件挂载完成后被调用","C":"onUpdated()函数会在组件更新前被调用","D":"onUnmounted()函数会在组件实例被销毁后调用"}, "a":"C", "desc":"**解析：** onUpdated() 是在组件更新**之后**被调用。更新之前调用的钩子是 onBeforeUpdate()。"},
  {"id":46, "type":"单选题", "q":"下列选项中，关于props说法错误的是（）。", "opts":{"A":"对非形式的props不能使用多种验证方案","B":"在声明props时通过添加default属性设置默认值","C":"在声明props时通过添加required属性设置必填项","D":"所有的props遵循单项数据流原则"}, "a":"A", "desc":"**解析：** props验证非常灵活，支持多种类型（如 [String, Number]），支持自定义验证函数 validator，所以A错误。"},
  {"id":47, "type":"单选题", "q":"下列选项中，关于跨组件之间数据传递说法错误的是（）。", "opts":{"A":"跨组件之间之前的数据共享可以通过依赖注入的方式来实现","B":"provide()函数可以提供一个值，可以被后代组件所注入","C":"对子组件而言，如果想要注入上层组件提供的数据，则需要使用inject()函数","D":"provide()函数可以接收2个参数，第1个参数要注入的值，第2个参数是注入名"}, "a":"D", "desc":"**解析：** provide(name, value)。第1个参数是**注入名**（key），第2个参数才是**要注入的值**（value）。D选项说反了。"},
  {"id":48, "type":"单选题", "q":"下列选项中，关于在使用setup语法糖时声明自定义事件的方式正确的是（）。", "opts":{"A":"emit()","B":"defineProps()","C":"defineEmits()","D":"props属性"}, "a":"C", "desc":"**解析：** 在 &lt;script setup&gt; 中，声明自定义事件需使用编译器宏 defineEmits()。"},
  {"id":49, "type":"单选题", "q":"下列选项中，关于在使用组件时监听自定义事件的指令说法正确的是（）。", "opts":{"A":"v-on","B":"v-bind","C":"v-model","D":"v-for"}, "a":"A", "desc":"**解析：** 无论是原生事件还是组件的自定义事件，都使用 v-on（或 @）进行监听。"},
  {"id":50, "type":"简答题", "q":"Vue 中事件使用什么指令绑定，请写出常见的五种事件修饰符", "a":"在 Vue 中，事件使用 v-on 指令绑定，可简写为 @。常见的五种事件修饰符包括：\n.stop：阻止事件冒泡\n.prevent：阻止默认行为\n.once：只触发一次\n.self：仅当事件是从元素本身触发时回调\n.capture：使用事件捕获模式", "desc":"在 Vue 中，事件使用 v-on 指令绑定，可简写为 @。常见的五种事件修饰符包括：\n.stop：阻止事件冒泡\n.prevent：阻止默认行为\n.once：只触发一次\n.self：仅当事件是从元素本身触发时回调\n.capture：使用事件捕获模式"},
  {"id":51, "type":"简答题", "q":"请简述 v-if 和 v-show 指令的区别", "a":"在 Vue 中，条件渲染指令分为 v-if 和 v-show 两种。v-show 与 v-if 都用来决定某一个元素是否在页面上显示出来。v-if 是根据布尔值切换元素的显示或隐藏状态，本质是通过操作 DOM 元素来切换显示状态。当给定的值为 true 时，元素存在于 DOM 树中；当给定的值为 false 时，元素从 DOM 树中移除。v-show 的原理是通过为元素添加或移除 display: none 样式来实现元素的显示或隐藏。当需要频繁切换某个元素的显示或隐藏时，使用 v-show 会更加节省性能上的开销；而当只需要切换一次显示或隐藏时，使用 v-if 更合理。", "desc":"在 Vue 中，条件渲染指令分为 v-if 和 v-show 两种。v-show 与 v-if 都用来决定某一个元素是否在页面上显示出来。v-if 是根据布尔值切换元素的显示或隐藏状态，本质是通过操作 DOM 元素来切换显示状态。当给定的值为 true 时，元素存在于 DOM 树中；当给定的值为 false 时，元素从 DOM 树中移除。v-show 的原理是通过为元素添加或移除 display: none 样式来实现元素的显示或隐藏。当需要频繁切换某个元素的显示或隐藏时，使用 v-show 会更加节省性能上的开销；而当只需要切换一次显示或隐藏时，使用 v-if 更合理。"},
  {"id":52, "type":"操作题", "q":"请使用 v-for 完成水果列表的渲染。", "a":"<template>\n  <div>\n    <p>水果列表</p>\n    <ul>\n      <li v-for=\"item in list\" :key=\"item.id\">\n        水果编号:{{ item.id }} -- 水果名称:{{ item.name }} -- 详细信息:{{ item.info }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst list = reactive([\n  {\n    id: 1,\n    name: '苹果',\n    info: '苹果汁水丰富，可以生津止渴。'\n  },\n  {\n    id: 2,\n    name: '柠檬',\n    info: '柠檬具有生津止渴、化痰止咳的功效。'\n  }\n])\n</script>", "desc":"操作题：v-for 列表渲染（修正版）。"},
  {"id":53, "type":"填空题", "q":"在Vue中，使用 ____ 标签可以定义动态组件。", "a":"<component>", "desc":"在Vue中，使用 &lt;component&gt; 标签可以定义动态组件。"},
  {"id":54, "type":"填空题", "q":"如果想要实现只有名称匹配的组件被缓存，可以通过KeepAlive组件的常用属性 ____ 来实现。", "a":"include", "desc":"如果想要实现只有名称匹配的组件被缓存，可以通过KeepAlive组件的常用属性 include 来实现。"},
  {"id":55, "type":"填空题", "q":"在&lt;slot&gt;标签内可以添加一些内容作为插槽的 ____。", "a":"默认内容", "desc":"在&lt;slot&gt;标签内可以添加一些内容作为插槽的 默认内容。"},
  {"id":56, "type":"填空题", "q":"如果要把内容填充到指定名称的插槽中，可以通过一个包含 ____ 指令的&lt;template&gt;标签来实现。", "a":"v-slot", "desc":"如果要把内容填充到指定名称的插槽中，可以通过一个包含 v-slot 指令的&lt;template&gt;标签来实现。"},
  {"id":57, "type":"填空题", "q":"如果没有使用setup语法糖，可以在 ____ 属性下声明私有自定义指令。", "a":"directives", "desc":"如果没有使用setup语法糖，可以在 directives 属性下声明私有自定义指令。"},
  {"id":58, "type":"判断题", "q":"使用动态组件实现组件之间的按需切换时，隐藏的组件会被销毁，展示出来的组件会被重新创建。", "a":"对", "desc":"**解析：** 默认情况下切换动态组件会销毁旧实例。如果需要保留状态不销毁，需要包裹 `<KeepAlive>` 组件。"},
  {"id":59, "type":"判断题", "q":"组件缓存可以使组件创建一次后，不会被销毁。", "a":"对", "desc":"**解析：** `<KeepAlive>` 的作用就是缓存组件实例，避免反复销毁和创建。"},
  {"id":60, "type":"判断题", "q":"作用域插槽是带有数据的插槽，父组件提供一部分数据给插槽。", "a":"错", "desc":"**解析：** 刚好反了。作用域插槽是**子组件**将数据提供给插槽，让**父组件**在渲染插槽内容时可以使用这些数据。"},
  {"id":61, "type":"判断题", "q":"如果一个组件没有预留任何插槽，则组件的使用者提供的任何插槽内容同样会起作用。", "a":"错", "desc":"**解析：** 如果组件内部没有 `<slot>` 标签，使用者传入的插槽内容会被直接丢弃，不会渲染。"},
  {"id":62, "type":"判断题", "q":"添加name属性的&lt;slot&gt;标签用来定义具名插槽。", "a":"对", "desc":"**解析：** 带有 name 属性的插槽称为具名插槽，不带 name 的默认为 default。"},
  {"id":63, "type":"单选题", "q":"下列选项中，当组件缓存时会触发的生命周期函数是（）。", "opts":{"A":"onActivated()","B":"onDeactivated()","C":"mounted()","D":"updated()"}, "a":"B", "desc":"**解析：** 当缓存的组件**失去活性**（被隐藏/切走）时，触发 onDeactivated。再次显示时触发 onActivated。"},
  {"id":64, "type":"单选题", "q":"下列选项中，关于插槽说法错误的是（）。", "opts":{"A":"插槽是组件组装期间为组件的使用者预留的占位符","B":"在定义插槽时，直接写一个&lt;slot&gt;标签，它属于默认插槽","C":"当需要使用多个插槽时，则需要为每个&lt;slot&gt;插槽指定具体的name属性","D":"如果组件的使用者为插槽提供内容，则默认内容生效"}, "a":"D", "desc":"**解析：** 如果使用者提供了插槽内容，则**覆盖**默认内容；默认内容仅在未提供内容时才显示。"},
  {"id":65, "type":"单选题", "q":"下列选项中，关于自定义指令说法错误的是（）。", "opts":{"A":"全局自定义指令可以在全局进行使用","B":"私有自定义指令只能在声明该指令的组件中使用","C":"在Vue中，可以通过app.directive()函数声明全局自定义指令","D":"在Vue中，不能为自定义指令绑定参数"}, "a":"D", "desc":"**解析：** 自定义指令可以接收参数（argument）和值。例如 v-my-directive:foo='bar'。"},
  {"id":66, "type":"单选题", "q":"下列选项中，关于自定义指令常用生命周期函数及传入参数说法错误的是（）。", "opts":{"A":"mounted()函数在绑定元素的父组件及自身的所有子节点都挂载完成后调用","B":"value为参数binding中的属性，表示传递给指令的值","C":"el参数表示当前指令所绑定到的元素","D":"beforeUpdate()函数在绑定的父组件卸载前调用"}, "a":"D", "desc":"**解析：** beforeUpdate 是在组件更新前调用。组件卸载前调用的是 beforeUnmount 或 unmounted。"},
  {"id":67, "type":"单选题", "q":"下列选项中，关于KeepAlive组件说法错误的是（）。", "opts":{"A":"KeepAlive组件通过&lt;KeepAlive&gt;标签来定义","B":"若只想把对应组件名的组件被缓存，则需要通过KeepAlive标签的exclude属性来实现","C":"在&lt;KeepAlive&gt;标签上添加max属性来设置最多可以缓存的组件实例个数","D":"只要被&lt;KeepAlive&gt;标签包裹的组件就不会被销毁"}, "a":"B", "desc":"**解析：** 想让组件**被缓存**（包含），使用的是 include 属性。exclude 是排除（不缓存）。"},
  {"id":68, "type":"简答题", "q":"请写出六个及以上常用内置指令，并解释其作用", "a":"以下是 Vue 中六个常用的内置指令及其作用：\nv-bind：动态绑定一个或多个属性或组件 prop，可简写为:。\nv-model：在表单元素或组件上创建双向数据绑定。\nv-on：绑定事件监听器，可简写为 @。\nv-if /v-else-if/v-else：根据条件决定是否渲染元素或组件。\nv-show：根据条件切换元素的显示 / 隐藏（通过 CSS display 属性）。\nv-for：基于源数据多次渲染元素或模板块。", "desc":"以下是 Vue 中六个常用的内置指令及其作用：\nv-bind：动态绑定一个或多个属性或组件 prop，可简写为:。\nv-model：在表单元素或组件上创建双向数据绑定。\nv-on：绑定事件监听器，可简写为 @。\nv-if /v-else-if/v-else：根据条件决定是否渲染元素或组件。\nv-show：根据条件切换元素的显示 / 隐藏（通过 CSS display 属性）。\nv-for：基于源数据多次渲染元素或模板块。"},
  {"id":69, "type":"简答题", "q":"请简述组合式 API 下的生命周期函数有哪些，分别在什么阶段执行？", "a":"onBeforeMount：组件挂载前。\nonMounted：组件挂载成功后。\nonBeforeUpdate：组件更新前。\nonUpdated：组件中的任意的 DOM 元素更新后。\nonBeforeUnmount：组件实例被销毁前。\nonUnmounted：组件实例被销毁后。", "desc":"onBeforeMount：组件挂载前。\nonMounted：组件挂载成功后。\nonBeforeUpdate：组件更新前。\nonUpdated：组件中的任意的 DOM 元素更新后。\nonBeforeUnmount：组件实例被销毁前。\nonUnmounted：组件实例被销毁后。"},
  {"id":70, "type":"操作题", "q":"编写登录和注册页面，通过动态组件实现动态切换。", "a":"<template>\n  <div>\n    <button @click=\"currentComp = 'Login'\">登录</button>\n    <button @click=\"currentComp = 'Register'\">注册</button>\n    \n    <hr>\n    \n    <keep-alive>\n      <component :is=\"tabs[currentComp]\"></component>\n    </keep-alive>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n// 假设已创建这两个组件文件\nimport Login from './Login.vue'\nimport Register from './Register.vue'\n\nconst currentComp = ref('Login')\nconst tabs = {\n  Login,\n  Register\n}\n</script>", "desc":"操作题：动态组件切换。"},
  {"id":71, "type":"填空题", "q":"Vue Router提供了Hash模式、____ (或 History) 模式来实现前端路由。", "a":"HTML5", "desc":"Vue Router提供了Hash模式、HTML5 (或 History) 模式来实现前端路由。"},
  {"id":72, "type":"填空题", "q":"在动态路由中，动态路径参数以 ____ 开头。", "a":":", "desc":"在动态路由中，动态路径参数以 : 开头。"},
  {"id":73, "type":"填空题", "q":"在路由匹配规则中，通过 ____ 属性可以定义子路由匹配规则。", "a":"children", "desc":"在路由匹配规则中，通过 children 属性可以定义子路由匹配规则。"},
  {"id":74, "type":"填空题", "q":"Hash模式通过URL中的 ____ 符号，实现不同组件之间的切换。", "a":"#", "desc":"Hash模式通过URL中的 # 符号，实现不同组件之间的切换。"},
  {"id":75, "type":"填空题", "q":"命名路由是通过 ____ 属性为路由规则定义路由名称。", "a":"name", "desc":"命名路由是通过 name 属性为路由规则定义路由名称。"},
  {"id":76, "type":"判断题", "q":"Vue Router中提供了默认的routers-link-active类名，为激活的路由链接设置高亮的样式。", "a":"错", "desc":"**解析：** 单词拼写错误。默认类名是 `router-link-active` (router 是单数)，不是 routers。"},
  {"id":77, "type":"判断题", "q":"Vue Router提供的导航守卫可以控制路由的访问权限。", "a":"对", "desc":"**解析：** 常在全局前置守卫 `beforeEach` 中判断用户是否登录，从而控制页面访问权限。"},
  {"id":78, "type":"判断题", "q":"Vue Router中可以在路由匹配规则中使用redirect属性设置路由重定向。", "a":"对", "desc":"**解析：** 例如 `{ path: '/', redirect: '/home' }`。"},
  {"id":79, "type":"判断题", "q":"在Vue中，页面有两种导航方式，分别是声明式导航和嵌套式导航。", "a":"错", "desc":"**解析：** 应该是 **声明式导航** (`<router-link>`) 和 **编程式导航** (`router.push`)。"},
  {"id":80, "type":"判断题", "q":"在Vue中，路由视图使用&lt;router-link&gt;标签定义。", "a":"错", "desc":"**解析：** 路由视图的占位符是 &lt;router-view&gt;。&lt;router-link&gt; 是用来点击跳转的链接。"},
  {"id":81, "type":"单选题", "q":"下列选项中，关于Vue Router全局前置守卫beforeEach()方法的说法错误的是（）。", "opts":{"A":"beforeEach()方法中接收to、from、next形参","B":"beforeEach()方法中to参数表示目标路由对象","C":"beforeEach()方法中from参数表示当前导航正要离开的路由对象","D":"beforeEach()方法中若省略next参数，则不允许用户访问任何一个路由"}, "a":"D", "desc":"**解析：** 在Vue Router 4中，next 参数是可选的。如果省略 next，守卫可以通过返回值控制跳转；如果不返回值，通常默认放行。即使在旧版本中，D的描述也过于绝对。"},
  {"id":82, "type":"单选题", "q":"下列选项中，vue-router的安装命令正确的是（）。", "opts":{"A":"yarn add vue-router@4","B":"node install vue-router@4","C":"npm install vueRouter@4","D":"npm i vue-router@4"}, "a":"A", "desc":"**解析：** 语法正确。B无node install命令；C包名大小写错误；D正确但A更规范。"},
  {"id":83, "type":"单选题", "q":"下列选项中，关于前、后端路由的说法错误的是（）。", "opts":{"A":"前端路由的整个过程发生在浏览器端","B":"后端路由的整个过程发生在服务器端","C":"Node.js环境中的Express框架中的路由属于后端路由","D":"Vue中的路由属于后端路由"}, "a":"D", "desc":"**解析：** Vue Router 是典型的前端路由，负责在浏览器端根据URL切换组件，不经过服务器。"},
  {"id":84, "type":"单选题", "q":"下列选项中，关于编程式导航的说法错误的是（）。", "opts":{"A":"router.go()方法的参数是一个整数，表示历史记录中向前或向后退的步数","B":"router.go()类似于window.history.go()","C":"router.go(1)表示向前移动一条记录","D":"router.go(-1)表示向后移动两条记录"}, "a":"D", "desc":"**解析：** router.go(-1) 表示向后退 **1** 条记录（相当于浏览器的后退按钮），而不是两条。"},
  {"id":85, "type":"单选题", "q":"下列选项中，关于命名路由的说法错误的是（）。", "opts":{"A":"命名路由通过name属性定义路由规则的名称","B":"命名路由的name属性值可以重复","C":"&lt;router-link&gt;标签的to属性用于跳转到指定目标地址","D":"在声明式导航中使用命名路由时，如&lt;router-link :to=\"{对象}\"&gt;，则对象中可以使用params属性指定跳转时携带的路由参数"}, "a":"B", "desc":"**解析：** 命名路由的 name 必须是**全局唯一**的，不能重复。"},
  {"id":86, "type":"简答题", "q":"组件注册的方式有几种？分别适用于什么样的场景", "a":"Vue 提供了两种注册组件的方式，分别是全局注册和局部注册。(1) 全局注册：如果某个组件的使用频率很高，许多组件中都会引用该组件，则推荐将该组件全局注册。被全局注册的组件可以在当前 Vue 项目的任何一个组件内引用。在 src\\main.js 文件中，通过 Vue 应用实例的 component () 方法可以全局注册组件。(2) 局部注册：如果某些组件只在特定的情况下被用到，推荐进行局部注册。局部注册即在某个组件中注册，被局部注册的组件只能在当前注册范围内使用。", "desc":"Vue 提供了两种注册组件的方式，分别是全局注册和局部注册。(1) 全局注册：如果某个组件的使用频率很高，许多组件中都会引用该组件，则推荐将该组件全局注册。被全局注册的组件可以在当前 Vue 项目的任何一个组件内引用。在 src\\main.js 文件中，通过 Vue 应用实例的 component () 方法可以全局注册组件。(2) 局部注册：如果某些组件只在特定的情况下被用到，推荐进行局部注册。局部注册即在某个组件中注册，被局部注册的组件只能在当前注册范围内使用。"},
  {"id":87, "type":"简答题", "q":"请简述如何解决组件之间的样式冲突", "a":"在 Vue 中，解决组件之间的样式冲突有以下 2 种方式：① scoped 属性：Vue 为<style>标签提供了 scoped 属性用于解决组件之间的样式冲突，例如<style scoped></style>。② 深度选择器：深度选择器通过:deep () 伪类来实现，在其小括号中可以定义用于子组件的选择器，例如:deep(.title)。", "desc":"在 Vue 中，解决组件之间的样式冲突有以下 2 种方式：① scoped 属性：Vue 为<style>标签提供了 scoped 属性用于解决组件之间的样式冲突，例如<style scoped></style>。② 深度选择器：深度选择器通过:deep () 伪类来实现，在其小括号中可以定义用于子组件的选择器，例如:deep(.title)。"},
  {"id":88, "type":"简答题", "q":"请简述组件之间的数据共享有哪几种方式", "a":"在 Vue 中，实现组件之间数据共享的方式有以下 3 种：① 通过 props 实现父组件向子组件中传递数据。② 通过自定义事件实现子组件向父组件中传递数据。③ 通过依赖注入实现跨级组件之间的数据传递。", "desc":"在 Vue 中，实现组件之间数据共享的方式有以下 3 种：① 通过 props 实现父组件向子组件中传递数据。② 通过自定义事件实现子组件向父组件中传递数据。③ 通过依赖注入实现跨级组件之间的数据传递。"},
  {"id":89, "type":"操作题", "q":"使用编程式导航实现页面跳转并携带参数。", "a":"// 在组件的 script setup 中\nimport { useRouter } from 'vue-router'\n\nconst router = useRouter()\n\nconst goToDetail = (id) => {\n  // 方式1：使用 name 和 params (需在路由配置中定义name: 'Detail')\n  router.push({\n    name: 'Detail',\n    params: { id: id }\n  })\n  \n  // 方式2：使用 path 和 query\n  // router.push({\n  //    path: '/detail',\n  //    query: { id: id }\n  // })\n}", "desc":"操作题：编程式导航。"},
  {"id":90, "type":"填空题", "q":"通过&lt;el-button&gt;标签的 ____ (或 circle) 属性可以将按钮设置为圆角按钮。", "a":"round", "desc":"通过&lt;el-button&gt;标签的 round (或 circle) 属性可以将按钮设置为圆角按钮。"},
  {"id":91, "type":"填空题", "q":"通过&lt;el-form&gt;标签的 ____ 属性可以将表单设置为行内表单。", "a":"inline", "desc":"通过&lt;el-form&gt;标签的 inline 属性可以将表单设置为行内表单。"},
  {"id":92, "type":"填空题", "q":"通过&lt;van-swipe&gt;标签的 ____ 属性可以开启图片的懒加载模式。", "a":"lazy-render", "desc":"通过&lt;van-swipe&gt;标签的 lazy-render 属性可以开启图片的懒加载模式。"},
  {"id":93, "type":"填空题", "q":"通过&lt;van-grid&gt;标签的 ____ 属性可以一行展示3个格子。", "a":"column-num", "desc":"通过&lt;van-grid&gt;标签的 column-num 属性可以一行展示3个格子。"},
  {"id":94, "type":"填空题", "q":"Ant Design Vue 组件库提供了 Layout 组件，该组件使用 ____ 标签定义顶部布局。", "a":"<a-layout>", "desc":"Ant Design Vue 组件库提供了 Layout 组件，该组件使用 &lt;a-layout&gt; 标签定义顶部布局。"},
  {"id":95, "type":"判断题", "q":"Element Plus 不支持 IE 11 及更低的 IE 版本。", "a":"对", "desc":"**解析：** Element Plus 专为 Vue 3 开发，使用了现代浏览器特性，不再支持 Internet Explorer。"},
  {"id":96, "type":"判断题", "q":"Ant Design Vue 组件库的 Layout 组件采用 Flex 布局。", "a":"对", "desc":"**解析：** 现代 UI 库的栅格和布局系统大多基于 Flexbox 实现。"},
  {"id":97, "type":"判断题", "q":"使用 use() 方法可以挂载 ElementPlus 模块。", "a":"对", "desc":"**解析：** 在 main.js 中使用 `app.use(ElementPlus)` 来全局注册组件库。"},
  {"id":98, "type":"判断题", "q":"&lt;van-field&gt;标签内可以通过 rule 属性定义校验规则。", "a":"对", "desc":"**解析：** Vant 表单域通过 rules (数组) 属性定义校验规则。"},
  {"id":99, "type":"判断题", "q":"Element Plus 中的 Menu 组件使用&lt;el-menu&gt;标签定义，菜单默认为水平模式。", "a":"错", "desc":"**解析：** &lt;el-menu&gt; 的 mode 属性默认值是 vertical (垂直模式)，设置为 horizontal 才是水平模式。"},
  {"id":100, "type":"单选题", "q":"下列选项中，使用包管理工具安装 Element Plus 组件库的命令正确的是（）。", "opts":{"A":"npm install element-plus","B":"yarn install element-plus","C":"npm add element-plus","D":"npm Install element-plus"}, "a":"A", "desc":"**解析：** 标准命令。yarn是用add，npm是用install (或 i)。"},
  {"id":101, "type":"单选题", "q":"在 Element Plus 组件库中，关于&lt;el-button&gt;标签中 type 属性的说法错误的是（）。", "opts":{"A":"type 属性设置为 danger，表示危险按钮","B":"type 属性设置为 info，表示主要按钮","C":"type 属性设置为 warning，表示警告按钮","D":"type 属性设置为 success，表示成功按钮"}, "a":"B", "desc":"**解析：** info 通常表示“信息”按钮（灰色）。“主要”按钮对应的 type 是 primary。"},
  {"id":102, "type":"单选题", "q":"在 Vant 组件库中，关于&lt;van-swipe&gt;标签的属性说法正确的是（）。", "opts":{"A":"autoplay 属性用于设置轮播图片的自动轮播间隔，单位为 s","B":"indicator-color 属性用于设置指示器颜色，默认值为#1998fa","C":"vertical 属性用于设置轮播图片为纵向滚动，默认设置为纵向滚动","D":"loop 属性用于设置轮播图片循环播放，默认值为 true"}, "a":"D", "desc":"**解析：** A单位通常是ms；B默认颜色通常是灰/白；C默认是横向；D默认开启循环播放是正确的。"},
  {"id":103, "type":"单选题", "q":"在 Vant 组件库中，关于&lt;van-grid-item&gt;标签的属性说法错误的是（）。", "opts":{"A":"icon 属性用于设置图标名称或图片链接","B":"text 属性用于设置图标的文字内容","C":"dot 属性用于设置图标右上角小黑点","D":"badge 属性用于设置图标右上角徽标的内容"}, "a":"C", "desc":"**解析：** dot 属性在 Vant 中用于展示“红点”（通常表示新消息），而不是“小黑点”。"},
  {"id":104, "type":"单选题", "q":"下列选项中，使用包管理工具安装 Vant 组件库的命令正确的是（）。", "opts":{"A":"npm add vant","B":"yarn install vant","C":"npm Install vant","D":"yarn add vant"}, "a":"D", "desc":"**解析：** yarn 添加依赖使用 add 命令。"},
  {"id":105, "type":"简答题", "q":"请简述 router.push () 和 router.go () 的区别", "a":"(1) router.push ()：push () 方法会向历史记录中添加一个新的记录，以编程方式导航到一个新的 URL，当用户单击浏览器后退按钮时，会回到之前的 URL。(2) router.go ()：go () 方法用于实现前进或后退的效果，其参数表示历史记录中前进或后退的步数，类似于 window.history.go ()，相应的地址栏也会发生改变。例如，go (1) 表示前进一条记录；go (-1) 表示后退一条记录。", "desc":"(1) router.push ()：push () 方法会向历史记录中添加一个新的记录，以编程方式导航到一个新的 URL，当用户单击浏览器后退按钮时，会回到之前的 URL。(2) router.go ()：go () 方法用于实现前进或后退的效果，其参数表示历史记录中前进或后退的步数，类似于 window.history.go ()，相应的地址栏也会发生改变。例如，go (1) 表示前进一条记录；go (-1) 表示后退一条记录。"},
  {"id":106, "type":"简答题", "q":"请简述导航守卫中参数 to、from、next 的含义", "a":"(1) to：表示目标路由对象。(2) from：表示当前导航正要离开的路由对象。(3) next：next 为函数，如果不接收 next () 函数，则默认允许用户访问每一个路由；如果接收了 next () 函数，则必须调用 next () 函数，否则不允许用户访问任何一个路由。", "desc":"(1) to：表示目标路由对象。(2) from：表示当前导航正要离开的路由对象。(3) next：next 为函数，如果不接收 next () 函数，则默认允许用户访问每一个路由；如果接收了 next () 函数，则必须调用 next () 函数，否则不允许用户访问任何一个路由。"},
  {"id":107, "type":"操作题", "q":"请使用 Vant 组件库的 type 属性实现 5 种基础按钮类型效果。", "a":"<van-button type=\"primary\">主要按钮</van-button>\n<van-button type=\"success\">成功按钮</van-button>\n<van-button type=\"default\">默认按钮</van-button>\n<van-button type=\"warning\">警告按钮</van-button>\n<van-button type=\"danger\">危险按钮</van-button>", "desc":"操作题：5种基础按钮类型。"},
  {"id":108, "type":"操作题", "q":"请使用 Vant 组件库的 Grid 组件实现图片和文字呈 2 行 3 列的网格效果。", "a":"<van-grid :column-num=\"3\">\n  <van-grid-item v-for=\"value in 6\" :key=\"value\" icon=\"photo-o\" text=\"文字\" />\n</van-grid>", "desc":"操作题：2行3列网格。"},
  {"id":109, "type":"填空题", "q":"Axios 在浏览器中使用 ____ 接口发送请求。", "a":"XMLHttpRequest", "desc":"Axios 在浏览器中使用 XMLHttpRequest 接口发送请求。"},
  {"id":110, "type":"填空题", "q":"Axios 运行在 Node.js 时，使用 ____ 对象发送请求。", "a":"http", "desc":"Axios 运行在 Node.js 时，使用 http 对象发送请求。"},
  {"id":111, "type":"填空题", "q":"Vuex 中的单向数据流包含状态、____ 和操作。", "a":"视图", "desc":"Vuex 中的单向数据流包含状态、视图 和操作。"},
  {"id":112, "type":"填空题", "q":"Pinia 简化了状态管理库的使用，抛弃了 ____，只有 state、getters 和 actions。", "a":"mutations", "desc":"Pinia 简化了状态管理库的使用，抛弃了 mutations，只有 state、getters 和 actions。"},
  {"id":113, "type":"填空题", "q":"通过 Pinia 的 pinia-plugin-persist 插件可以实现数据的 ____ 存储。", "a":"持久化", "desc":"通过 Pinia 的 pinia-plugin-persist 插件可以实现数据的 持久化 存储。"},
  {"id":114, "type":"判断题", "q":"Axios 可以作用于 Node.js 和浏览器中。", "a":"对", "desc":"**解析：** Axios 是一个同构库，在浏览器端使用 XMLHttpRequests，在 Node.js 端使用 http 模块。"},
  {"id":115, "type":"判断题", "q":"Axios 支持拦截请求和响应。", "a":"对", "desc":"**解析：** Axios 提供了 `interceptors.request` and `interceptors.response` 用于拦截处理。"},
  {"id":116, "type":"判断题", "q":"Vuex 是专为 Vue.js 应用程序开发的状态管理库。", "a":"对", "desc":"**解析：** Vuex 是 Vue 的官方状态管理模式（Vue 2 时代主流，Vue 3 推荐 Pinia 但 Vuex 仍可用）。"},
  {"id":117, "type":"判断题", "q":"Pinia 支持 Vue 3，不支持 Vue 2，支持组合式 API。", "a":"错", "desc":"**解析：** Pinia 同时支持 Vue 2 和 Vue 3。它是 Vuex 的下一代替代品。"},
  {"id":118, "type":"判断题", "q":"在 Pinia 中可以通过 paths 实现部分数据持久化存储。", "a":"对", "desc":"**解析：** 配合 `pinia-plugin-persistedstate` 插件时，可以使用 `paths` 数组指定只持久化 state 中的某些字段。"},
  {"id":119, "type":"单选题", "q":"下列选项中，关于 Axios 特性的说法错误的是（）。", "opts":{"A":"支持拦截请求和响应","B":"可以转换请求数据和响应数据","C":"安全性高，客户端支持防御 CSRF","D":"Axios 不支持 post 请求"}, "a":"D", "desc":"**解析：** Axios 完美支持 GET, POST, PUT, DELETE 等各种 HTTP 请求方法。"},
  {"id":120, "type":"多选题", "q":"下列选项中，关于 Vuex 中 state、mutations、actions 和 modules 的说法正确的是（）（多选）。", "opts":{"A":"state 用于管理数据，且数据是响应式的，当数据改变时驱动视图更新","B":"mutations 用于更新数据，state 中的数据只能使用 mutations 改变","C":"actions 用于定义事件处理方法，把数据提交给 mutations，可以直接修改 state","D":"modules 用于定义模块对象"}, "a":"A、B、D", "desc":"**解析：** C错误，Actions **不能直接修改 state**，必须通过 context.commit 提交 mutation 来修改数据。Actions 主要用于处理异步操作."},
  {"id":121, "type":"单选题", "q":"下列选项中，关于 Pinia 的说法错误的是（）。", "opts":{"A":"Pinia 提供了完整的 TypeScript 支持","B":"Pinia 使用 modules 划分模块，代码更加简洁","C":"Pinia 支持 Devtools 调试工具，方便进行调试","D":"Pinia 支持服务端渲染"}, "a":"B", "desc":"**解析：** Pinia 的一大改进就是 **弃用了** Vuex 那种嵌套的 modules 结构。在 Pinia 中，每个 store 都是独立的，扁平化设计，不需要模块嵌套。"},
  {"id":122, "type":"简答题", "q":"请写出 2 种路由中动态路径参数值的获取方式，并简单阐述使用步骤", "a":"(1) 使用 $route.params 获取参数值：直接从路由实例的 params 对象中提取动态路径参数，适用于所有组件。步骤：\n定义动态路由（路径中用：参数名）；\n导航到该路由；\n在组件中通过 route.params. 参数名获取。比如定义路径 '/user/:id'，然后导航时传递 id，组件里用 $route.params.id 拿。\n(2) 使用 props 获取参数值：将路由的 params 对象转换为组件的 props。步骤：\n定义动态路由时开启 props（可以是布尔值、对象或函数）；\n在组件中声明 props 接收参数；\n直接使用 props 中的参数。", "desc":"(1) 使用 $route.params 获取参数值：直接从路由实例的 params 对象中提取动态路径参数，适用于所有组件。步骤：\n定义动态路由（路径中用：参数名）；\n导航到该路由；\n在组件中通过 route.params. 参数名获取。比如定义路径 '/user/:id'，然后导航时传递 id，组件里用 $route.params.id 拿。\n(2) 使用 props 获取参数值：将路由的 params 对象转换为组件的 props。步骤：\n定义动态路由时开启 props（可以是布尔值、对象或函数）；\n在组件中声明 props 接收参数；\n直接使用 props 中的参数。"},
  {"id":123, "type":"简答题", "q":"请简述 Vuex 中 state、mutations、gettes、actions 和 modules 的作用", "a":"Vuex 中主要包含以下 5 个部分：\nState：单一状态树，提供应用中各种状态的存储处。\nGetters：从 State 中派生出来的状态，类似于 Vue 组件中的 computed 属性。\nMutations：同步函数，用于更改 State 中的状态，每个 Mutation 必须同步执行。\nActions：异步函数，用于处理异步操作，并在必要时提交 Mutation。\nModules：模块化 Vuex 存储，允许将 store 分割成模块。", "desc":"Vuex 中主要包含以下 5 个部分：\nState：单一状态树，提供应用中各种状态的存储处。\nGetters：从 State 中派生出来的状态，类似于 Vue 组件中的 computed 属性。\nMutations：同步函数，用于更改 State 中的状态，每个 Mutation 必须同步执行。\nActions：异步函数，用于处理异步操作，并在必要时提交 Mutation。\nModules：模块化 Vuex 存储，允许将 store 分割成模块。"},
  {"id":124, "type":"简答题", "q":"请简述 Pinia 的主要优点", "a":"① Pinia 支持 Vue 2 和 Vue 3，支持选项式 API 和组合式 API 写法。\n② Pinia 简化了状态管理库的使用方法，抛弃了 mutations，只有 state、getters 和 actions，让代码编写更容易也更直观。\n③ Pinia 不需要嵌套模板，符合 Vue 3 中的组合式 API，让代码更加扁平化。\n④ Pinia 提供了完整的 TypeScript 支持。\n⑤ Pinia 分模块不需要借助 modules，使代码更加简洁，可以实现良好的代码自动分割。⑥ Pinia 支持 Devtools 调试工具，便于进行调试。\n⑦ Pinia 体积更小，性能更好。\n⑧ Pinia 支持在某个组件中直接修改 Pinia 的 state 中的数据。\n⑨ Pinia 支持服务器端渲染。", "desc":"① Pinia 支持 Vue 2 和 Vue 3，支持选项式 API 和组合式 API 写法。\n② Pinia 简化了状态管理库的使用方法，抛弃了 mutations，只有 state、getters 和 actions，让代码编写更容易也更直观。\n③ Pinia 不需要嵌套模板，符合 Vue 3 中的组合式 API，让代码更加扁平化。\n④ Pinia 提供了完整的 TypeScript 支持。\n⑤ Pinia 分模块不需要借助 modules，使代码更加简洁，可以实现良好的代码自动分割。⑥ Pinia 支持 Devtools 调试工具，便于进行调试。\n⑦ Pinia 体积更小，性能更好。\n⑧ Pinia 支持在某个组件中直接修改 Pinia 的 state 中的数据。\n⑨ Pinia 支持服务器端渲染。"},
  {"id":125, "type":"简答题", "q":"请简述如何使用 Pinia 实现数据持久化局部存储。", "a":"需要在定义 store 时，通过 persist 属性配置。例如使用 pinia-plugin-persistedstate 插件，在 defineStore 的第二个参数选项中添加 persist: { paths: ['saveItem'] }，指定需要持久化的 state 路径。", "desc":"Pinia 数据持久化局部存储。"},
  {"id":126, "type":"操作题", "q":"使用 Pinia 实现年龄的持久化存储，初始值 20，点击按钮自增 1，刷新后保持修改后的值。", "a":"// 1. store/age.js\nimport { defineStore } from 'pinia'\nexport const useAgeStore = defineStore('age', {\n  state: () => ({\n    age: 20\n  }),\n  actions: {\n    increment() {\n      this.age++\n    }\n  },\n  // 开启持久化 (前提是已安装并注册了 pinia-plugin-persistedstate)\n  persist: true\n})\n\n// 2. 组件中使用\n/*\n<template>\n  <div>\n    <h1>年龄：{{ ageStore.age }}</h1>\n    <button @click=\"ageStore.increment\">年龄+</button>\n  </div>\n</template>\n\n<script setup>\nimport { useAgeStore } from './store/age'\nconst ageStore = useAgeStore()\n<\/script>\n*/", "desc":"操作题：Pinia 持久化存储。"}
]